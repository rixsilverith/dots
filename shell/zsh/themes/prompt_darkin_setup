#!/usr/bin/zsh

DARKIN_PROMPT_ADD_NEWLINE="${DARKIN_PROMPT_ADD_NEWLINE=false}"
DARKIN_PROMPT_SHORT_PWD="${DARKIN_PROMPT_SHORT_PWD=true}"
DARKIN_PROMPT_DIR_PREFIX="${DARKIN_PROMPT_DIR_PREFIX="in "}"
DARKIN_PROMPT_SHOW_USER="${DARKIN_PROMPT_SHOW_USER=false}"
DARKIN_PROMPT_SHOW_GIT_REPO_STATUS="${DARKIN_PROMPT_SHOW_GIT_REPO_STATUS=true}"
DARKIN_PROMPT_MINIMAL_GIT_REPO_STATUS="${DARKIN_PROMPT_MINIMAL_GIT_REPO_STATUS=true}"

GIT_BRANCH_SYMBOL=" "

if [[ $DARKIN_PROMPT_MINIMAL_GIT_REPO_STATUS == true ]]; then
    GIT_CLEAN_STATUS_SYMBOL=""
    GIT_DIRTY_STATUS_SYMBOL="*"
    GIT_BEHIND_STATUS_SYMBOL="  "
    GIT_AHEAD_STATUS_SYMBOL="  "
    GIT_DIVERGED_STATUS_SYMBOL="  "
else
    GIT_CLEAN_STATUS_SYMBOL=" ✓"
    GIT_DIRTY_STATUS_SYMBOL=" ✗"
    GIT_BEHIND_STATUS_SYMBOL="  "
    GIT_AHEAD_STATUS_SYMBOL="  "
    GIT_DIVERGED_STATUS_SYMBOL="  "
fi

GIT_SYNCED_STATUS_SYMBOL=""

darkin_user() {
    local user=""
    [[ $DARKIN_PROMPT_SHOW_USER == true ]] && user="$(whoami) "
    echo $user
}

darkin_dir() {
    local dir="$(pwd)"
    local dir_segment="${dir/$HOME/~}"

    if [[ $DARKIN_PROMPT_SHORT_PWD == true && $dir != $HOME ]]; then
        # Hmm... yeah WTF. Stolen with <3 from https://github.com/CodelyTV/dotly/blob/master/scripts/core/short_pwd
        dir=$(echo ${${${:-/${(j:/:)${(M)${(s:/:)${(D)PWD:h}}#(|.)[^.]}}/${PWD:t}}//\/~/\~}/\/\//\/})
        dir_segment="$dir"
    fi

    echo "$DARKIN_PROMPT_DIR_PREFIX$dir_segment"
}

darkin_git() {
    [[ $(git rev-parse --is-inside-work-tree &> /dev/null; echo "$?") != '0' ]] && return
    local -r git_current_branch="$(git symbolic-ref -q --short HEAD)"
    local git_segment=" on $GIT_BRANCH_SYMBOL$git_current_branch"

    if [[ $DARKIN_PROMPT_SHOW_GIT_REPO_STATUS == true ]]; then
        git_repo_status=$(git diff --quiet --ignore-submodules HEAD &> /dev/null; echo "$?")
        [[ $git_repo_status == '1' ]] && git_repo_status="$GIT_DIRTY_STATUS_SYMBOL" || git_repo_status="$GIT_CLEAN_STATUS_SYMBOL"

        # Ensure the Git repo is not empty and that it has an upstream branch to avoid reference errors
        if [[ $(git log &> /dev/null; echo "$?") == '0' && $(git rev-parse --symbolic-full-name ${git_current_branch}@{u} &> /dev/null; echo "$?") == '0' ]]; then
            local -r upstream='@{u}'
            local -r loc=$(git rev-parse @)
            local -r remote=$(git rev-parse "$upstream")
            local -r base=$(git merge-base @ "$upstream")

            if [[ "$loc" == "$remote" ]]; then git_repo_status="$git_repo_status$GIT_SYNCED_STATUS_SYMBOL";
            elif [[ "$loc" == "$base" ]]; then git_repo_status="$git_repo_status$GIT_BEHIND_STATUS_SYMBOL";
            elif [[ "$remote" == "$base" ]]; then git_repo_status="$git_repo_status$GIT_AHEAD_STATUS_SYMBOL";
            else git_repo_status="$git_repo_status$GIT_DIVERGED_STATUS_SYMBOL"; fi
        fi

        git_segment="$git_segment$git_repo_status"
    fi

    echo $git_segment
}

darkin_prompt() {
    prompt_darkin="$(tput bold)$(darkin_user)$(darkin_dir)$(darkin_git)$(tput sgr0)"
    echo "$prompt_darkin "
}

prompt_darkin_setup() {
    autoload -Uz vcs_info
    autoload -Uz add-zsh-hook

    # This variable is a magic variable used when loading themes with zsh's prompt
    # function. It will ensure the proper prompt options are set.
    prompt_opts=(cr percent sp subst)

    # Fetch Git info when entering a command.
    add-zsh-hook precmd vcs_info

    PROMPT='$(darkin_prompt)'
    PS1='$(darkin_prompt)'

    [[ $DARKIN_PROMPT_ADD_NEWLINE == true ]] && PS1="$PS1"$'\n> '

    unset RPS1
}

prompt_darkin_setup "$@"
